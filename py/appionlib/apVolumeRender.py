#!/usr/bin/env python3
"""
Headless volume rendering helpers (pure Python, no Chimera dependency).
Uses scikit-image marching cubes + matplotlib (Agg) for snapshots/animations,
and a tiny STL writer for 3D-print exports.
"""

from pathlib import Path

import numpy
from PIL import Image, ImageChops
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import colors as mcolors
from matplotlib import use as mpl_use
from skimage import measure

# Force headless rendering
mpl_use("Agg")


def _default_level(volume):
	# Heuristic: mid-way between mean and max to avoid flat zero.
	vol = numpy.asarray(volume, dtype=numpy.float32)
	if vol.size == 0:
		return 0.0
	mean = float(vol.mean())
	maxv = float(vol.max())
	minv = float(vol.min())
	if maxv == minv:
		return maxv
	return mean + 0.2 * (maxv - mean)


def extract_mesh(volume, level=None, spacing=(1.0, 1.0, 1.0)):
	vol = numpy.asarray(volume, dtype=numpy.float32)
	if level is None:
		level = _default_level(vol)
	verts, faces, _, _ = measure.marching_cubes(vol, level=level, spacing=spacing)
	return verts, faces


def _write_stl_binary(verts, faces, out_path):
	out = Path(out_path)
	with out.open("wb") as f:
		f.write(b"Generated by apVolumeRender" + b"\0" * (80 - len("Generated by apVolumeRender")))
		f.write(numpy.uint32(len(faces)).tobytes())
		for tri in faces:
			p0, p1, p2 = verts[tri]
			normal = numpy.cross(p1 - p0, p2 - p0)
			norm_len = numpy.linalg.norm(normal)
			if norm_len != 0:
				normal = normal / norm_len
			else:
				normal = numpy.array([0.0, 0.0, 0.0], dtype=numpy.float32)
			f.write(normal.astype("<f4").tobytes())
			for pt in (p0, p1, p2):
				f.write(pt.astype("<f4").tobytes())
			f.write(b"\0\0")  # attribute byte count


def export_stl(verts, faces, out_path):
	_write_stl_binary(verts, faces, out_path)


def _cylindrical_colors(verts):
	radius = numpy.sqrt(verts[:, 0] ** 2 + verts[:, 1] ** 2)
	max_r = float(radius.max())
	if max_r == 0:
		return numpy.zeros_like(radius)
	return radius / max_r


def _face_colors(verts, faces, scalar_field, cmap):
	norm = mcolors.Normalize(vmin=float(scalar_field.min()), vmax=float(scalar_field.max()))
	per_face = scalar_field[faces].mean(axis=1)
	return cmap(norm(per_face))


def _render_view(ax, verts, faces, elev, azim, cmap):
	colors = _cylindrical_colors(verts)
	face_colors = _face_colors(verts, faces, colors, cmap)
	tri = ax.plot_trisurf(
		verts[:, 0],
		verts[:, 1],
		verts[:, 2],
		triangles=faces,
		shade=False,
		linewidth=0.0,
		antialiased=True,
	)
	tri.set_facecolors(face_colors)
	ax.view_init(elev=elev, azim=azim)
	ax.set_axis_off()
	ax.set_box_aspect([1, 1, 1])


def _get_background_color(image: Image.Image):
	# Use the top-left pixel as the background color heuristic.
	return image.getpixel((0, 0))


def _trim_image(path):
	with Image.open(path) as img:
		bg_color = _get_background_color(img)
		bg = Image.new(img.mode, img.size, bg_color)
		diff = ImageChops.difference(img, bg)
		diff = ImageChops.add(diff, diff, 2.0, -0)
		bbox = diff.getbbox()
		if bbox:
			img.crop(bbox).save(path)


def render_png_views(verts, faces, basename, imgsize=1024, cmap_name="viridis"):
	out_base = Path(basename)
	cmap = cm.get_cmap(cmap_name)
	views = [(0, 0, 1), (0, 90, 2), (90, 0, 3)]
	for elev, azim, idx in views:
		fig = plt.figure(figsize=(imgsize / 100.0, imgsize / 100.0), dpi=100)
		ax = fig.add_subplot(111, projection="3d")
		_render_view(ax, verts, faces, elev, azim, cmap)
		out_path = f"{out_base}.{idx}.png"
		fig.savefig(out_path, bbox_inches="tight", pad_inches=0)
		try:
			_trim_image(out_path)
		except Exception:
			pass
		plt.close(fig)


def render_animation_gif(verts, faces, basename, imgsize=512, n_frames=36, elev=30.0, cmap_name="viridis"):
	out_base = Path(basename)
	tmp_dir = out_base.parent
	cmap = cm.get_cmap(cmap_name)
	frames = []
	fig = plt.figure(figsize=(imgsize / 100.0, imgsize / 100.0), dpi=100)
	ax = fig.add_subplot(111, projection="3d")
	for i in range(n_frames):
		ax.clear()
		_render_view(ax, verts, faces, elev, azim=(360.0 / n_frames) * i, cmap=cmap)
		frame_path = tmp_dir / f"{out_base.name}.frame_{i:03d}.png"
		fig.savefig(frame_path, bbox_inches="tight", pad_inches=0)
		frames.append(Image.open(frame_path))
	plt.close(fig)

	if frames:
		out_gif = out_base.with_suffix(".animate.gif")
		frames[0].save(
			out_gif,
			save_all=True,
			append_images=frames[1:],
			duration=100,
			loop=0,
		)
	return Path(basename)
