#!/usr/bin/env python3
"""
Headless volume rendering helpers (pure Python, no Chimera dependency).
Uses scikit-image marching cubes + matplotlib (Agg) for snapshots/animations,
and a tiny STL writer for 3D-print exports.
"""

import math
import tempfile
from pathlib import Path

import numpy
from PIL import Image
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import use as mpl_use
from skimage import measure

# Force headless rendering
mpl_use("Agg")


def _default_level(volume):
	# Heuristic: mid-way between mean and max to avoid flat zero.
	vol = numpy.asarray(volume, dtype=numpy.float32)
	if vol.size == 0:
		return 0.0
	mean = float(vol.mean())
	maxv = float(vol.max())
	minv = float(vol.min())
	if maxv == minv:
		return maxv
	return mean + 0.2 * (maxv - mean)


def extract_mesh(volume, level=None, spacing=(1.0, 1.0, 1.0)):
	vol = numpy.asarray(volume, dtype=numpy.float32)
	if level is None:
		level = _default_level(vol)
	verts, faces, _, _ = measure.marching_cubes(vol, level=level, spacing=spacing)
	return verts, faces


def _write_stl_binary(verts, faces, out_path):
	out = Path(out_path)
	with out.open("wb") as f:
		f.write(b"Generated by apVolumeRender" + b"\0" * (80 - len("Generated by apVolumeRender")))
		f.write(numpy.uint32(len(faces)).tobytes())
		for tri in faces:
			p0, p1, p2 = verts[tri]
			normal = numpy.cross(p1 - p0, p2 - p0)
			norm_len = numpy.linalg.norm(normal)
			if norm_len != 0:
				normal = normal / norm_len
			else:
				normal = numpy.array([0.0, 0.0, 0.0], dtype=numpy.float32)
			f.write(normal.astype("<f4").tobytes())
			for pt in (p0, p1, p2):
				f.write(pt.astype("<f4").tobytes())
			f.write(b"\0\0")  # attribute byte count


def export_stl(verts, faces, out_path):
	_write_stl_binary(verts, faces, out_path)


def _cylindrical_colors(verts):
	theta = numpy.arctan2(verts[:, 1], verts[:, 0])
	val = (theta + math.pi) / (2.0 * math.pi)
	return val


def _render_view(ax, verts, faces, elev, azim, cmap):
	colors = _cylindrical_colors(verts)
	tri = ax.plot_trisurf(
		verts[:, 0],
		verts[:, 1],
		faces,
		verts[:, 2],
		shade=True,
		linewidth=0.0,
		antialiased=True,
		cmap=cmap,
	)
	tri.set_array(colors)
	ax.view_init(elev=elev, azim=azim)
	ax.set_axis_off()
	ax.set_box_aspect([1, 1, 1])


def render_png_views(verts, faces, basename, imgsize=1024):
	out_base = Path(basename)
	cmap = cm.get_cmap("viridis")
	views = [(0, 0, 1), (0, 90, 2), (90, 0, 3)]
	for elev, azim, idx in views:
		fig = plt.figure(figsize=(imgsize / 100.0, imgsize / 100.0), dpi=100)
		ax = fig.add_subplot(111, projection="3d")
		_render_view(ax, verts, faces, elev, azim, cmap)
		fig.savefig(out_base.with_suffix(f".{idx}.png"), bbox_inches="tight", pad_inches=0)
		plt.close(fig)


def render_animation_gif(verts, faces, basename, imgsize=512, n_frames=36, elev=30.0):
	tmp_dir = Path(tempfile.mkdtemp(prefix="render_frames_"))
	cmap = cm.get_cmap("viridis")
	frames = []
	fig = plt.figure(figsize=(imgsize / 100.0, imgsize / 100.0), dpi=100)
	ax = fig.add_subplot(111, projection="3d")
	for i in range(n_frames):
		ax.clear()
		_render_view(ax, verts, faces, elev, azim=(360.0 / n_frames) * i, cmap=cmap)
		frame_path = tmp_dir / f"frame_{i:03d}.png"
		fig.savefig(frame_path, bbox_inches="tight", pad_inches=0)
		frames.append(Image.open(frame_path))
	plt.close(fig)

	if frames:
		out_gif = Path(basename).with_suffix(".animate.gif")
		frames[0].save(
			out_gif,
			save_all=True,
			append_images=frames[1:],
			duration=100,
			loop=0,
		)
	return Path(basename)
