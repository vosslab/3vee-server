#!/usr/bin/env python3
"""
Headless volume rendering helpers (pure Python, no Chimera dependency).
Uses scikit-image marching cubes + matplotlib (Agg) for snapshots/animations,
and a tiny STL writer for 3D-print exports.
"""

from pathlib import Path

import numpy
from PIL import Image, ImageChops, ImageFilter, ImageOps
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib import colors as mcolors
from matplotlib import use as mpl_use
from skimage import measure

# Force headless rendering
mpl_use("Agg")


def _default_level(volume):
	# Heuristic: mid-way between mean and max to avoid flat zero.
	vol = numpy.asarray(volume, dtype=numpy.float32)
	if vol.size == 0:
		return 0.0
	mean = float(vol.mean())
	maxv = float(vol.max())
	minv = float(vol.min())
	if maxv == minv:
		return maxv
	return mean + 0.2 * (maxv - mean)


def extract_mesh(volume, level=None, spacing=(1.0, 1.0, 1.0)):
	vol = numpy.asarray(volume, dtype=numpy.float32)
	if level is None:
		level = _default_level(vol)
	verts, faces, _, _ = measure.marching_cubes(vol, level=level, spacing=spacing)
	return verts, faces


def _write_stl_binary(verts, faces, out_path):
	out = Path(out_path)
	with out.open("wb") as f:
		f.write(b"Generated by apVolumeRender" + b"\0" * (80 - len("Generated by apVolumeRender")))
		f.write(numpy.uint32(len(faces)).tobytes())
		for tri in faces:
			p0, p1, p2 = verts[tri]
			normal = numpy.cross(p1 - p0, p2 - p0)
			norm_len = numpy.linalg.norm(normal)
			if norm_len != 0:
				normal = normal / norm_len
			else:
				normal = numpy.array([0.0, 0.0, 0.0], dtype=numpy.float32)
			f.write(normal.astype("<f4").tobytes())
			for pt in (p0, p1, p2):
				f.write(pt.astype("<f4").tobytes())
			f.write(b"\0\0")  # attribute byte count


def export_stl(verts, faces, out_path):
	_write_stl_binary(verts, faces, out_path)

def export_obj(verts, faces, out_path):
	out = Path(out_path)
	with out.open("w", encoding="ascii") as f:
		f.write("# Generated by apVolumeRender\n")
		for v in verts:
			f.write("v %.6f %.6f %.6f\n" % (v[0], v[1], v[2]))
		for tri in faces:
			f.write("f %d %d %d\n" % (tri[0] + 1, tri[1] + 1, tri[2] + 1))


def _cylindrical_colors(verts):
	radius = numpy.sqrt(verts[:, 0] ** 2 + verts[:, 1] ** 2)
	max_r = float(radius.max())
	if max_r == 0:
		return numpy.zeros_like(radius)
	return radius / max_r


def _face_colors(verts, faces, scalar_field, cmap):
	norm = mcolors.Normalize(vmin=float(scalar_field.min()), vmax=float(scalar_field.max()))
	per_face = scalar_field[faces].mean(axis=1)
	return cmap(norm(per_face))


def _render_view(ax, verts, faces, elev, azim, cmap):
	colors = _cylindrical_colors(verts)
	face_colors = _face_colors(verts, faces, colors, cmap)
	tri = ax.plot_trisurf(
		verts[:, 0],
		verts[:, 1],
		verts[:, 2],
		triangles=faces,
		shade=False,
		linewidth=0.0,
		antialiased=True,
	)
	tri.set_facecolors(face_colors)
	ax.view_init(elev=elev, azim=azim)
	ax.set_axis_off()
	ax.set_box_aspect([1, 1, 1])


def _trim_image(path, tolerance=5):
	with Image.open(path) as img:
		arr = numpy.asarray(img.convert("RGB"))
		bg = arr[0, 0].astype(int)
		diff = numpy.abs(arr.astype(int) - bg[None, None, :])
		mask = (diff > tolerance).any(axis=2)
		coords = numpy.argwhere(mask)
		if coords.size == 0:
			return
		y0, x0 = coords.min(axis=0)
		y1, x1 = coords.max(axis=0) + 1
		img.crop((x0, y0, x1, y1)).save(path)


def _add_silhouette(path, width=2, color=(0, 0, 0), strength=1.8, threshold=20):
	if width <= 0:
		return
	try:
		with Image.open(path).convert("RGBA") as img:
			# Find edges on luminance; thicker dilation approximates toon silhouette.
			luma = ImageOps.autocontrast(img.convert("L"))
			edges = luma.filter(ImageFilter.FIND_EDGES)
			edges = edges.point(lambda p: min(255, int(p * strength)))
			edges = edges.point(lambda p: 255 if p > threshold else 0)
			edges = edges.filter(ImageFilter.MaxFilter(width * 2 + 1))
			if edges.getbbox() is None:
				return

			stroke = Image.new("RGBA", img.size, color + (255,))
			stroke.putalpha(edges)
			out = Image.alpha_composite(img, stroke)
			out.save(path)
	except Exception:
		return


def render_png_views(verts, faces, basename, imgsize=1024, cmap_name="viridis", silhouette_width=0):
	out_base = Path(basename)
	cmap = cm.get_cmap(cmap_name)
	views = [(0, 0, 1), (0, 90, 2), (90, 0, 3)]
	for elev, azim, idx in views:
		fig = plt.figure(figsize=(imgsize / 100.0, imgsize / 100.0), dpi=100)
		ax = fig.add_subplot(111, projection="3d")
		_render_view(ax, verts, faces, elev, azim, cmap)
		out_path = f"{out_base}.{idx}.png"
		fig.savefig(out_path, bbox_inches="tight", pad_inches=0)
		try:
			_add_silhouette(out_path, width=silhouette_width)
			_trim_image(out_path)
		except Exception:
			pass
		plt.close(fig)


def render_animation_gif(
	verts,
	faces,
	basename,
	imgsize=512,
	n_frames=36,
	elev=30.0,
	cmap_name="viridis",
	silhouette_width=0,
):
	out_base = Path(basename)
	tmp_dir = out_base.parent
	cmap = cm.get_cmap(cmap_name)
	frames = []
	fig = plt.figure(figsize=(imgsize / 100.0, imgsize / 100.0), dpi=100)
	ax = fig.add_subplot(111, projection="3d")
	for i in range(n_frames):
		ax.clear()
		_render_view(ax, verts, faces, elev, azim=(360.0 / n_frames) * i, cmap=cmap)
		frame_path = tmp_dir / f"{out_base.name}.frame_{i:03d}.png"
		fig.savefig(frame_path, bbox_inches="tight", pad_inches=0)
		try:
			_add_silhouette(frame_path, width=silhouette_width)
			_trim_image(frame_path)
		except Exception:
			pass
		with Image.open(frame_path) as frame:
			frames.append(frame.copy())
	plt.close(fig)

	if frames:
		out_gif = out_base.with_suffix(".animate.gif")
		frames[0].save(
			out_gif,
			save_all=True,
			append_images=frames[1:],
			duration=100,
			loop=0,
		)
	return Path(basename)
